C lang Version has achieved 70% success. - 20260113

The program runs without crashing and can generate graphics using shaders, but... currently there's an issue with image loading—fonts and graphics aren't loading properly. It's likely a parameter passed incorrectly somewhere. The worst part is that it doesn't crash, forcing me to debug it bit by bit... 

C lang Version has achieved 80% success. - 20260114

The issue is resolved—both images and text are now displaying correctly. It took nearly two hours to tweak each parameter one by one...

问题解决了，图像文字都已经正常，一个个参数调了快两个小时……

This is a pitfall with TeaVM : it doesn't pass buffer object settings to externally passed *void objects. That means any settings you configure—like limit or position—won't take effect. If you pass any buffer object externally, it defaults to passing only the *void object it resides within. Any buffer object settings you configure externally remain invalid when passed as parameters. The engine (regardless of whether you use loon) typically performs various operations on buffers, and rarely does a Buffer exist without any configuration. Therefore, passing it directly as an argument is almost always incorrect. In such cases, you must repackage the data yourself and provide OpenGL with a new array address. But that's not the end of it. Since these are new values, and GL has its own data callback, TeaVM won't synchronize them back to the original Buffer. To retrieve the data modified by GL, you must handle the retrieval yourself. This introduces a new problem: generating large arrays of byte*, float*, int*, etc., severely drains engine efficiency. That's why you see everyone defaulting to new arrays, resulting in FPS dropping to around 50...

这是TeaVM的坑，他不会将Buffer对象的设定传递给外传的*void，也就是你设定有limit，设定有position之类，这些都不生效，你如果把任意Buffer对象往外传的话，默认只能传其内部所在*void对象，如果你在外部做过任何Buffer对象的设置，这个设定在对外传参上都无效，而引擎（不论你是否使用loon）一般都会各种操作Buffer，很少Buffer没有任何设置的，所以直接传参大多数时候当然就是错的，这时你必须自己重新打包数据，然后new一个新数组地址给opengl，这还不算完，因为是新值，然后gl有回调数据teavm他当然也不会同步到旧有Buffer，要得到被gl改变后的数据，你还要自己接回来。这又产生一个新问题，就是大量byte*,float*.int*之类数组的产生，会拖垮引擎效率，所以大家看全部直接上新数组默认fps只剩50左右了……

Then, with no other choice, I had to write my own cache register solution. The frame rate has finally reached 60 FPS. If you need it, feel free to take the VMBufferConvert class. For cases requiring data to be sent back, use the save and restore combination. If not needed, just call ofNAddress directly—it'll save you hours of trial and error.

然后被逼无奈，我只能自己写缓存器解决，目前速度终于上60FPS了，有需要的可以把VMBufferConvert这个类拿去，需要回传的调用save和restore组合，不需要的直接调用ofNAddress，少走几小时弯路，我知道隔壁也在写C版，从代码上我还知道他不太会用TeaVM的C版，然后我打赌他看不懂中文……